import jwt from 'jsonwebtoken'
import cookie from 'cookie'
import accessControl from 'access-control'

export const secret = process.env.JWT_SECRET || `i456asfdADFafadil_w`

// A GraphQL schema, using SDL (schema definition language)
export const typeDefs = `#gql
  """
    Authentication type User
  """
  type User {
    email: String
    token: String
  }

  """
    Returns current user
  """
  type Query {
    user: User
  }

  """
    Authentication API Mutations
  """
  type Mutation {
    """
      Returns User object with Autorization token
    """
    login( email: String password: String ): User
    """
      Returns empty object
    """
    logout: User
  }
`

//  Resolver definition for each API endpoint â€” js object
export const resolvers = {
  Query: {
    user: accessControl(user)
  },
  Mutation: {
    login: (_1,params) => login(params),
    logout: accessControl(logout),
  }
}

function login({email,password}) {
  if (!email || email.length === 0) throw new Error('Email required!')
  if (!password || password.length === 0) throw new Error('Password required!')
  const token = jwt.sign({ email }, secret,{ expiresIn: '1d' });
  return {email,token}
}

function logout({ctx}) {
  const token = ctx.token
  const blacklist = blacklistGargabgeCollect(ctx.blacklist).push({token,exp:ctx.user.exp})
  const cookieName = 'blacklist'
  const cookieValue = JSON.stringify(blacklist)
  const cookieOptions = { httpOnly: true, maxAge: 60 * 60 * 24 * 365 /* 1 year */}
  ctx.res.setHeader( 'Set-Cookie', cookie.serialize( cookieName, cookieValue, cookieOptions));
  return {}
}

function blacklistGargabgeCollect(ctx) {
  const now = (new Date()).valueOf()
  return [...ctx.blacklist.filter( item => item.exp*1000 > now )]
}

export function user(ctx) {
  return {...ctx.user,token:ctx.token}
}

export default {typeDefs,resolvers,secret}
