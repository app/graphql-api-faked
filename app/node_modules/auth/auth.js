import jwt from "jsonwebtoken";
import cookie from "cookie";
import accessControl from "access-control";

export const secret = process.env.JWT_SECRET || `i456asfdADFafadil_w`;

// A GraphQL schema, using SDL (schema definition language)
export const typeDefs = `#gql
  """
    Authentication type User
  """
  type User {
    email: String
    token: String
  }

  type Query {
    """
      Returns current user  
      Expects HTTP header  {"Authorization": "Bearer <token>"}
    """
    user: User
  }

  type Mutation {
    """
      Returns User object with Autorization token
    """
    login( email: String password: String ): User
    """
      Returns empty object
    """
    logout: User
  }
`;

//  Resolver definition for each API endpoint â€” js object
export const resolvers = {
  Query: {
    user: accessControl(user),
  },
  Mutation: {
    login: (_1, params) => login(params),
    logout: accessControl(logout),
  },
};
// Helper functions

function blacklistGargabgeCollect(blacklist) {
  const now = new Date().valueOf();
  return [...blacklist.filter((item) => item.exp * 1000 > now)];
}

// Resolvers only please :)

function login({ email, password }) {
  if (!email || email.length === 0) throw new Error("Email required!");
  if (!password || password.length === 0) throw new Error("Password required!");
  const token = jwt.sign({ email }, secret, { expiresIn: "1d" });
  return { email, token };
}

function logout({ ctx }) {
  const token = ctx.token;
  const blacklist = blacklistGargabgeCollect(ctx.blacklist);
  blacklist.push({ token, exp: ctx.user.exp });
  const cookieName = "blacklist";
  const cookieValue = JSON.stringify(blacklist);
  const cookieOptions = {
    httpOnly: true,
    maxAge: 60 * 60 * 24 * 365 /* 1 year */,
  };
  ctx.res.setHeader(
    "Set-Cookie",
    cookie.serialize(cookieName, cookieValue, cookieOptions)
  );
  return {};
}

export function user({ ctx }) {
  return { ...ctx.user, token: ctx.token };
}

export default { typeDefs, resolvers, secret };
